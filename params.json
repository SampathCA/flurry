{"name":"Flurry","tagline":"Unique id generation service","body":"Flurry is a \"unique id\" generation service written in scala, but accesible in any language using thrift. Flurry took its inspiration (and very little code) from Twitter's snowflake service, but by starting from scratch, we have what I think is a cleaner implementation, less dependencies, and it's easily configurable and runnable.\r\n\r\n\r\n## Running\r\n\r\nFlurry comes with a service wrapper, which allows it to run on linux or OSX.  In order to run Flurry, follow the instructions below.\r\n\r\n1. Download a [release archive](https://github.com/BazuSports/flurry/releases)\r\n2. Unzip the release archive and cd into the application directory\r\n3. Use the service wrapper to run Flurry (i.e. _service/flurry_)\r\n\r\n\r\n## Configuration\r\n\r\nFlurry allows you to provide you own configuration file to override the default properties.  The default configuration is below.\r\n\r\n    flurry {\r\n        server-port = 9090\r\n\r\n        generator-class = com.chronotrack.flurry.ConfigurableGenerator\r\n\r\n        generator-config {\r\n            worker-id-generator-class = com.chronotrack.flurry.worker.StaticWorkerIdGenerator\r\n            workerId                  = 2\r\n            epochStart                = 1376937222000\r\n            workerIdBits              = 14\r\n            sequenceBits              = 10\r\n        }\r\n    }\r\n\r\n\r\nIn order to override the values, you can put a file named application.conf in the flurry application directory and restart the flurry service.\r\n\r\nHere is an example of a custom configuration file.  You can omit any values you're not overriding as they will be infered from the default configuration.\r\n\r\n    flurry {\r\n        server-port = 9091\r\n\r\n        generator-config {\r\n            worker-id-generator-class = com.chronotrack.flurry.worker.HostWorkerIdGenerator\r\n        }\r\n    }\r\n\r\n\r\n### Configuration properties\r\n\r\n* **server-port** - the port on which the thrift server will listen on\r\n\r\n* **generator-class** - the implementation class of the generator (for now, flurry only supports the ConfigurableGenerator class)\r\n\r\n* **generator-config** - configurations used by the generator\r\n\r\n    * **worker-id-generator-class** - the class the is responsible for generating the worker id.  There are currently two\r\n    supported classes (HostWorkerIdGenerator and StaticWorkerIdGenerator)\r\n    * **workerId** - If you are using StaticWorkerIdGenerator, you can specify a static worker id using this option\r\n    * **epochStart** - The start of the epoch time for your software (once you create this, changing it can and will create collisions)\r\n    * **workerIdBits** - The number of bits to use for the worker part of the 64 bit id\r\n    * **sequenceBits** - The number of bits to use fot the sequence bit part of the id\r\n\r\n_64 - (workerIdBits + sequenceBits) is the number of bits used for the time part of the id, so make sure you leave enough to support however long of a period you think you need.\r\n(i.e. 40 bits = 2^40 = 1099511627776. Divide by 3.15569e10 [milliseconds in a year] and you get 34.8 years._\r\n\r\n_Same goes for worker id and sequence._\r\n\r\n* _14 bits for worker id = 2^14 = 16384 unique machines you can support._\r\n* _10 bits for sequence = 2^10 = 1024 ids per millisecond per worker you can support._\r\n    \r\n_You can tune your time, worker, sequence support as needed for your application_\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}